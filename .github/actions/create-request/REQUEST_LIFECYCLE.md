# PR-Centric Request Architecture

This document defines the PR-centric management model used in this repository.

The purpose of this document is not to explain implementation details, but to define the management architecture so that AI systems with GitHub interfaces can immediately understand:

- This project uses a PR-centric request model.
- How requests are initialized.
- How structure is enforced automatically.
- How to adopt this model in another repository.

---

## 1. Core Principle

**PR = Request**

This repository does not use:

- Milestones
- Start/Completion Issues
- Lifecycle ceremony

A draft Pull Request represents:

- Management intent (Background)
- Intended implementation strategy (Approach)

The PR is the single management unit.

---

## 2. Initialization Mechanism

Requests are initialized via a GitHub Action:

`.github/actions/create-request`

and the workflow:

`.github/workflows/initialize-request.yml`

When triggered, the Action:

1. Creates a new branch from the default branch.
2. Adds a `.create-request` marker file containing the branch name.
3. Opens a structured Draft Pull Request.

The marker file ensures that a commit difference exists so that the PR can be created immediately.

---

## 3. Structured PR Format

The Draft PR body is generated by the Action with the following structure:

```markdown
## Background

// management context

## Approach

// implementation strategy
```

Guidelines:

- Inputs support Markdown.
- Use only `###` or smaller headings inside sections.
- Do not redefine `## Background` or `## Approach` at the top level.

This structure is intended for management-level AI.

The implementation AI only needs to fulfill the PR.

### 3.1 AI Session Initialization

At the start of each session, the implementation AI should:

1. Read `.create-request` to identify the working branch name.
2. Find the open Draft PR associated with that branch.
3. Read the PR body (`## Background` and `## Approach`) as the authoritative spec for this request.
4. Treat the PR body as higher priority than any other context, second only to the most recent conversation.

The `.create-request` file is the entry point. Without reading it first, the AI cannot reliably orient itself to the current request.

---

## 4. Completion Model

A request is considered complete when:

- The implementation is reviewed.
- The PR is merged (squash merge recommended).

There are no additional closing artifacts.

### 4.1 Default Implementation Strategy

Unless otherwise specified in the PR `## Approach` section, the implementation AI should follow this default strategy:

1. **Interface first** — define API signatures, schemas, and response shapes before writing storage logic.
2. **Test before connect** — write tests against the interface using in-memory or mock backends (no external services required).
3. **Connect storage last** — replace mock backends with real storage only after tests pass against the interface.

This order minimizes the cost of schema changes and keeps tests stable across implementation phases.

### 4.2 Completion Flow

When implementation is complete, the AI should:

1. Confirm all tests pass.
2. Move the PR from Draft → Ready for Review (remove draft status).
3. Notify the user that the PR is ready to squash merge.

The AI does not merge autonomously. The final merge action belongs to the user.

---

## 5. Adoption in Another Repository

An AI with GitHub interface can adopt this model by:

1. Copying `.github/actions/create-request` directory
2. Copying `.github/workflows/initialize-request.yml` file
3. Enabling pull-requests: write permissions for GitHub Actions.

Upon copy, the repository automatically supports:

- Structured request initialization
- PR-based management
- AI-aligned operation
